\chapter{Theoretische Grundlagen Wegfindung}

\section{Modellierung der Anlagentopologie}
	\label{Graph_Anlage}
	Zur Berechnung eines Weges innerhalb der Anlage wird zuallererst die Topologie der besagten Anlage benötigt. Für die Funktionsweise der \ac{FTF} wurde definiert, das sich alle Fahrzeuge mittels optischer Merkmale auf einer definierten Teilstrecke bewegen. Zudem soll es den Fahrzeugen nur an festgelegten Entscheidungspunkten möglich sein, ihren Fahrzustand zu ändern und eine andere Teilstrecke. Dies bedeutet, das alle Fahrzeuge, sobald sie sich für eine Teilstrecke entschieden haben, dieser bis zum nächsten Entscheidungspunkt folgen. Auf Basis einer solchen logischen Unterteilung der Anlage in Entscheidungspunkte und Teilstrecken als Verbindungen zwischen zwei solcher Punkte, liegt es nahe als Datenstruktur für die Modellierung der Anlagentopologie einen Graphen zu verwenden. Die Entscheidungspunkte entsprechen hierbei den Knoten und die korrespondierenden Teilwegstrecken stellen die Kanten des Graphen dar. Da sich die \ac{FTF} möglichst frei durch die Produktion bewegen sollen, wird als Grundform der Anlage ein ungerichteter Graph zur Abbildung der Topologie verwendet, jedoch soll es für die spätere Wegberechnung unerheblich sein, ob es sich um einen gerichteten oder ungerichteten Graphen handelt.\\
	\textbf{insert graphic about graphs here}\\
	Da der Graph die Abbildung einer realen Anlage ist, kann zudem ausgeschlossen werden, dass die Gewichtung der Kanten negativ ist, da dies je nach Art der Gewichtung nur wenig Nutzen bringen würde. Es existieren beispielsweise keine negativen Streckenabstände oder Fahrzeiten, die eine spezielle Betrachtung erforderlich machen und somit die Wahl der Wegfindungsalgorithmen einschränken würden.
	
\section{Auswahl der Algorithmen}

	Es existieren mehrere Algorithmen, welche sich mit der Problemstellung der Berechnung eines kürzesten Pfads zwischen zwei Knoten eines gewichteten Graphen befassen. Um einen passende Vorgehensweise auswählen zu können muss zuerst definiert werden, welche Kriterien ein potentieller Wegfindungsalgorithmus erfüllen muss.
	
	\subsection{Auswahlkriterien}
		\label{Kriterien_Alg}
		Für ein geeignetes Wegfindungssystem müssen die folgenden Aspekte berücksichtigt werden:
		\begin{enumerate}
			\item Die Berechnung soll auf einer \ac{SPS} des niedrigen Leistungssegments durchgeführt werden. Somit müssen die daraus resultierenden Beschränkungen bezüglich Komplexität  und Speicherbedarf erfüllt sein.
			\item Eine \ac{SPS} ist ein Echtzeitsystem, welches das Programm zyklisch abarbeitet. Gleichzeitig wird auf der Steuerung auch die Fahraufgabe realisiert. Dadurch muss die Rechenzeit kurz genug sein, um eine Reaktionsfähigkeit des Fahrprogramms sicherstellen zu können.
			\item Die Wegfindung soll während der Ausführung eines vorausberechneten Fahrauftrags auf andere Fahrzeuge oder Änderungen der Anlagentopologie reagieren können.
			\item Es soll ein optimaler Weg gefunden werden. Optimal bedeutet im vorliegenden Fall einen möglichst kurzen Weg zum Zielknoten.
			\item Die Anlage soll möglichst gleichmäßig ausgelastet sein in Bezug auf Bearbeitungsstationen mit gleicher Funktionalität.
		\end{enumerate}
		
		Eine \ac{SPS}, wie sie in 1. beschrieben ist, erlaubt nur eine geringe Schachtelungstiefe der Unterprogrammaufrufe. Dies beschränkt den Einsatz von rekursiven Algorithmen auf Anwendungen bei denen die Anzahl der Rekursionen von vornherein bekannt ist. Da die Anlagen aber beliebiger Art sein sollen, können Algorithmen die Rekursion verwenden nicht genutzt werden. Zudem fallen für die Implementierung diejenigen Algorithmen heraus, die nur sehr umständlich in der begrenzten Programmierumgebung für Echtzeitsteuerungen realisiert werden können.\\
		Die Einhaltung der in Punkt 2 beschriebenen Echtzeitbedingung ist keine generelle Frage des Algorithmus sonder ist Sache der Implementierung. Hier müssen Programmteile mit Schleifenkonstrukten möglicherweise aufgebrochen und die Berechnung auf verschiedene Zyklen aufgeteilt werden.\\
		Die in 3. erwähnte Reaktionsfähigkeit erfordert von den Algorithmen, das sie auch in nur teilweise bekannten Umgebungen sicher einen Weg finden können. Für das Zusammenspiel ist eine Methode für die Vorhersage der Positionen anderer Fahrzeuge notwendig.\\
		Da aus Gründen der Anlageneffizienz die Laufzeit eines Werkstücks durch die Anlage möglichst minimiert werden soll, wird von dem Wegfindungsalgorithmus gemäß Punkt 4 erwartet, dass er nicht nur schnell einen möglichen Weg findet, sondern dass der gefundene Weg auch der kürzeste, mit den begrenzten Anlageninformationen berechenbare, Pfad zum Zielknoten ist.\\
		Da die in 5. erwähnte gleichmäßige Auslastung mehr mit der Auswahl des geeigneten Zielknotens als mit der eigentlichen Wegfindung zu diesem Ziel zu tun hat, ist diese Anforderung nur begrenzt für die Auswahl der Algorithmen von Bedeutung.
		
	\subsection{Betrachtete Algorithmen}
		\label{Betrachtete_Algorithmen}
		Im Angesicht der in \ref{Kriterien_Alg} ermittelten Auswahlkriterien wurden die folgenden Algorithmen näher betrachtet:
		
		\begin{longtable}{p{2.5cm} p{10cm}}
			
			\textbf{Dijkstra :} & Einer der Grundalgorithmen für das Kürzeste-Pfad-Problem, bei dem auch die Entfernungen aller Knoten zu einem Startknoten ermittelt werden können.\\[0.5cm]
			\textbf{A* :} & Eine Abwandlung des Dijkstra-Algorithmus, bei dem die Anzahl der betrachteten knoten verringert werden kann, indem Zusatzinformationen in Form einer Heuristik als Entscheidungshilfe für die Betrachtungsreihenfolge verwendet werden.\\[0.5cm]
			\textbf{\ac{MA*}\cite{Chakrabarti1989}:} &	Dieser Algorithmus beschränkt den Speicherverbrauch indem er den Topologiegraphen in Teilbäume unterteilt und nur erfolgversprechende Knoten und Teilgraphen im Speicher behält.\\[0.5cm]
			\textbf{\ac{RTA*}\cite{Korf1990}:} & Dieser Algorithmus unterteilt den Hauptalgorithmus in  Planungs- und Ausführungsphasen und beschränkt die Anzahl der betrachteten Knoten anhand einer Alpha-Beta-Suche. Durch diese Unterteilung kann ein gewisses Maß an Dynamik gewonnen werden, da der Algorithmus nach jeder Ausführungsphase die Restroute neu evaluiert und gegebenenfalls die aktuelle Route gegen einen neuen optimierten Weg ersetzt.\\[0.5cm]
			\textbf{\ac{D*}\cite{DStarAlg}\cite{Koenig2005}:} & Dieser Algorithmus wurde entwickelt für Topologien, welche nur teilweise bekannt sind, beziehungsweise die sich dynamisch verändern können. Zeiger die entlang des jeweils kürzesten Weges vom aktuellen Knoten zum Startknoten zeigen werden bei Anlagenänderung durch sogenannte "`Modify-Cost-Operationen"' ausgehend von der Anlagenänderung kaskadierend modifiziert bis sich ein neuer statischer Zustand eingestellt hat. Die Wegberechnung nutzt diese Zeiger zur schnelleren Berechnung des kürzesten Pfades.\\[0.5cm]
			
		\end{longtable}
		
		Der Dijkstra-Algorithmus ist aufgrund seiner langen Berechnungszeit ungeeignet für die Wegfindung im laufenden Betrieb der \ac{FTF} jedoch kann ausgenutzt werden, das bei der Berechnung des kürzesten Pfades via Dijkstra die Abstände aller berechneten Knoten zum Startknoten ermittelt werden. Diese Abstände bilden die Basis zur Verbesserung der bei einem der Anderen Algorithmen genutzten Heuristiken. Die Algorithmen \ac{MA*}, \ac{RTA*} und \ac{D*} sind alle Weiterentwicklungen des A*-Algorithmus.  Da die zu entwickelnde Anlage im vorliegenden Fall nur eine Begrenzte Anzahl von Knoten besitzt, ist der Nachteil des hohen Speicherbedarfs des Grundalgorithmus A* hier vernachlässigbar. Somit kann der zusätzliche Aufwand für die Implementierung von \ac{MA*} zunächst ignoriert werden. Der \ac{D*}-Algorithmus wurde wegen seiner höheren Komplexität und der Beschränkungen durch die Programmierumgebung nicht implementiert. Als zyklischen Wegfindungsalgorithmus wurde eine Mischform des A*-Algorithmus mit der Planungs- und Ausführungsphase von \ac{RTA*} verwendet, bei der in regelmäßigen Abständen der bisher gefundene Teilweg verifiziert und bei Bedarf neu berechnet wird. Die verwendeten Algorithmen sollen nun etwas näher betrachtet werden.
		
	
\section{Dijkstra-Algorithmus}
	Der Erste der insgesamt zwei für die Wegfindung verwendeten Algorithmen ist der nach seinem Erfinder benannte Dijkstra-Algorithmus, der den kürzesten Pfad zwischen einem Startknoten und einem Endknoten\footnote{oder allen anderen Knoten.} eines Graphen ermittelt. Er kann verwendet werden für beliebige positiv gewichtete, gerichtete oder ungerichtete Graphen. Da in \ref{Graph_Anlage} negative Kantengewichtungen ausgeschlossen wurden, lässt sich der Algorithmus ohne Abwandlung auf den Graphen der Anlagentopologie anwenden.
	\subsection{Grundprinzip}
		\label{Dijkstra_Alg}
		Das Grundprinzip des Dijkstra-Algorithmus ist Unterteilung aller Graphenknoten in drei Untergruppen\cite{DijkstraAlg}:
		
		\begin{tabular}{p{2.5cm} p{10cm}}	
			\textbf{Gruppe A:} & Die Menge aller Knoten, zu dem bereits ein kürzester Pfad bekannt ist.\\[0.25cm]
			\textbf{Gruppe B:} & Die Menge aller Knoten, die mit mindestens einem Knoten aus Gruppe A verbunden sind, jedoch selbst nicht zu A gehören.\\[0.25cm]
			\textbf{Gruppe C:} & Die Menge der restlichen Knoten, die nicht in den Gruppen A oder B enthalten sind.\\[0.25cm]
		\end{tabular}
		
		Zusätzlich zu den Knoten können auch die Kanten drei unterschiedlichen Teilgruppen zugeordnet werden\cite{DijkstraAlg}:
		
		\begin{tabular}{p{2.5cm} p{10cm}}
			\textbf{Gruppe I:} & Die Menge aller Kanten, die in einem kürzesten Pfad zu einem der Knoten aus Gruppe A vorkommen.\\[0.25cm]
			\textbf{Gruppe II:} & Die Menge aller Kanten, aus denen die nächste Kante für Gruppe I ausgewählt wird, wenn der korrespondierende Knoten aus B zur Gruppe A hinzugefügt wird. Es existiert immer genau eine Kante für jeden Knoten aus Gruppe B. \\[0.25cm]
			\textbf{Gruppe III:} & Die restlichen Kanten.\\[0.25cm]
		\end{tabular}
		
		Der Algorithmus funktioniert nun wie folgt. Zu Beginn befinden sich alle Knoten und Kanten respektive in den Gruppen C oder III. Als erstes wird nun der Startknoten S zu A hinzugefügt, da ein kürzester Pfad vom Startknoten zu sich selbst mit dem Wert 0 bekannt ist. Ab nun werden folgende Schritte solange wiederholt, bis das Ziel erreicht wurde:
		\begin{center}
			\begin{minipage}{0.8\linewidth}

				\begin{enumerate}
					\item Man betrachte alle Kanten \textit{z} die den soeben zu A hinzugefügten Knoten mit einem Knoten \textit{K} aus B oder C verbinden. 
					\begin{itemize}
						\item Gehört \textit{K} zur Gruppe B, so wird untersucht ob \textit{z} zu einem kürzeren Pfad zu \textit{K} führt als der bisherige kürzeste Pfad mit einer Kante aus II zu diesem Knoten. Ist dies der Fall, so ersetzt \textit{z} die korrespondierende Kante aus II. Die Kante die durch \textit{z} wird wieder zur Gruppe III hinzugefügt.
						\item Gehört \textit{K} zur Gruppe  C, so wird \textit{K} zu B und \textit{z} zu II hinzugefügt.
					\end{itemize}
					\item Es existiert immer nur jeweils ein Weg vom Startknoten zu einem beliebigen Knoten von B unter Verwendung der Kanten aus I und II. Nun wird derjenige Knoten aus B zur Gruppe A hinzugefügt, dessen Weg der kürzeste ist. Analog wird die zugehörige Kante der Gruppe I zugeordnet.
				\end{enumerate}
			\end{minipage}
		\end{center}
	\subsection{Darstellung der Funktionsweise}
		Die \textbf{insert graphic here} zeigt die Funktionsweise des Algorithmus an einem einfachen Beispielgraphen mit vier Knoten.
	
	\subsection{Berechnungsaufwand}
		Der Berechnungsaufwand des Dijkstra-Algorithmus beträgt in Landau-Notation vereinfacht $\mathcal{O}(\lvert \mathcal{V}\rvert ^2)$ beziehungsweise $\mathcal{O}(\lvert \mathcal{V}\rvert  \log \lvert \mathcal{V}\rvert + \lvert \mathcal{E}\rvert) $ bei der Implementierung mittels Fibonacci-Heaps\cite{Fredman1984} wobei  $\mathcal{V} $ gleich der Anzahl der Knoten  und $\mathcal{E}$ gleich der Anzahl der Kanten des Graphen ist. diese Vereinfachung gilt jedoch nur, wenn die Anzahl der Kanten in der gleichen Größenordnung liegt wie die Anzahl der Knoten.
	
\section{A*-Algorithmus}
	Der zweite verwendete Algorithmus für die Wegfindung ist der sogenannte A*-Algorithmus. Dieser ist eine Weiterentwicklung des in \ref{Dijkstra_Alg} vorgestellten Dijkstra-Algorithmus. Der grundlegende Unterschied ist jedoch, das bei A* eine Bewertung der Betrachtungsreihenfolge von Knoten bei der Berechnung verwendet werden. Dies bedeutet, dass diejenigen Knoten und Kanten zuerst expandiert werden sollen, bei denen die Wahrscheinlichkeit höher ist, das sie Teil des kürzesten Pfades zum Zielknoten sind. Im Vergleich dazu wurde beim Dijkstra-Algorithmus immer genau der Knoten als nächstes expandiert, der den kürzesten Abstand zu den bereits expandierten Knoten hatte\textbf{Insert graphic dijkstra vs A*}. Um eine Abschätzung der Wahrscheinlichkeit eines Knotens bezüglich seiner Zugehörigkeit zu dem  kürzesten Pfad vom Start zum Zielknoten treffen zu können, werden somit zusätzliche Informationen über die Beziehung zwischen einzelnen Knoten und dem Zielknoten benötigt. Diese Bewertung von Knoten wird auch als Heuristik bezeichnet. Mittels dieser Bewertung kann nun bereits vor Erreichen des Zielknotens eine Aussage über die Länge der Route gemacht werden.
	\subsection{Grundprinzip}
		\label{A*-Alg}
		Die Funktionsweise des A*-Algorithmus kann somit wie folgt als Erweiterung des Dijkstra-Algorithmus beschrieben werden\cite{Hart1968}:
		\begin{center}
			\begin{minipage}{0.8\linewidth}
				\begin{itemize}
					\item \textit{Seien $s$, $n$ und $z$ beliebige Knoten des Graphen $G$, wobei $s$ der Startknoten und $z$ der Zielknoten für die Ermittlung des kürzesten Weges von $s$ zu $z$ sind.}\\
					\item \textit{Sei $f(n)$ eine Funktion zur Abschätzung der Pfadlänge vom Knoten $s$ zum Knoten $z$, welcher den Knoten $n$ enthält.}
				\end{itemize}
		
				\begin{enumerate}
					\item Man markiere $s$ als "`offen"' und berechne $f(s)$.
					\item Man wähle denjenigen offenen Knoten $n$ aus, der den  kleinsten Wert für $f(n)$ besitzt.
					\item Falls $n=z$, wird $n$ als "`geschlossen"' markiert und beende den Algorithmus.
					\item Andernfalls markiere man $n$ als "`geschlossen"' und füge alle von $n$ erreichbaren Knoten $n'$ zur Liste der offenen Knoten hinzu, die noch nicht als geschlossen markiert wurden und berechne $f(n')$. 	Man springe zurück zu Schritt 2.
				\end{enumerate}
			\end{minipage}
		\end{center}
		
		Man sieht das somit bei dem A*-Algorithmus diejenigen Knoten bevorzugt betrachtet werden, die durch die Abschätzungsfunktion als "`wahrscheinlicher zum Ziel führend"' bewertet wurden. Somit ist es nur sinnvoll diesen Bewertungsvorgang näher zu betrachten. 
		
	
	
	
	\subsection{Abschätzungsfunktion f(n)}
		\label{Abschaetz}
		Die Abschätzungsfunktion, die in \ref{A*-Alg} definiert wurde, kann unterteilt werden in zwei Unterfunktionen\cite{Hart1968}:
		\begin{equation}
			f(n)=g(n)+h(n)
		\end{equation}
		
		$g(n)$ beschreibt hierbei den Wert des kürzesten Pfads von $s$ zu $n$ und $h(n)$ beschreibt den Wert des Pfades von $n$ zum Ziel $z$.
		
		Da die genauen Werte für $g(n)$ und $f(n)$ im Verlauf der Berechnung aber möglicherweise noch nicht exakt bestimmbar sind \footnote{exakt bestimmbar sind diese erst wirklich beim erreichen des Zielknotens $z$ und sukzessivem Beenden des Algorithmus.}, werden Schätzwerte für $g(n)$ und $h(n)$ verwendet. Sei somit $\hat{g}(n)$ der Wert des bisher gefundenen kürzesten Pfads von $s$ zu $n$ und sei $\hat{h}(n)$ der Wert der Heuristik des Pfads von $n$ zum Ziel $z$ so folgt als Abschätzung für $f(n)$
		\begin{equation}
			\hat{f}(n)=\hat{g}(n)+\hat{h}(n)
		\end{equation}
		
		Man kann nun beweisen das für alle Knoten $n$, die als offen markiert sind, der kürzeste Pfad vom Startknoten aus bereits bekannt ist, und somit gilt:
		\begin{equation}
			\hat{g}(n)=g(n)
		\end{equation}
		Da davon ausgegangen werden kann, das alle Pfade $g(k_i)$ für bereits geschlossene Knoten $k$ bekannt und minimal sind und somit auch gilt\footnote{analog zu \ref{Dijkstra_Alg} Schritt 2 mit $v_{k,n}$ als die Gewichtung der Kante zwischen den Knoten $k$ und $n$.}
		\begin{equation}
			\hat{g}(n)=g(k_i)+min(v_{k_i,n})=g(n)
		\end{equation}
		 muss nur noch die Heuristik $\hat{h}(n)$ definiert werden.
		 Es kann bewiesen werden, das der A*-Algorithmus konsistent ist, das heißt, dass jeder bereits geschlossene Knoten nicht erneut geöffnet werden muss, wenn gilt:
		 \begin{equation}
			 \hat{h}(n)\le h(n).
		 \end{equation}
		 Für die Berechnung bedeutet dies, dass wir den Wert des Restpfades von $n$ zu dem Zielknoten $z$ durch die Heuristik zwar unterschätzen dürfen, falls wir aber für die Berechnung einen möglichst effizienten Algorithmus benötigen, wir die Heuristik auf keinen Fall überschätzen dürfen.
		
		
		
	
	\subsection{Vergleich verschiedener Heuristiken h(n)}
		\label{Heuristik}
		Die in Kapitel \ref{Abschaetz} besprochene Abschätzungsfunktion $f(n)$ hat einen großen Einfluss auf das Verhalten des A*-Algorithmus.
		Zur Veranschaulichung sollen einige Möglichkeiten für die Heuristiken betrachtet werden\cite{Patel2016}:
		\begin{enumerate}
			\item \textbf{$\hat{h}(n)=0$:} Wenn der Wert der Heuristik konstant auf Null gesetzt wird, so ist dies gleich zu setzen damit, als würden keine Zusatzinformationen zur Berechnung der Route verwendet. Dies bedeutet das immer genau der Knoten aus der Menge von offenen Punkten ausgewählt wird, dessen Abstand zu einem der geschlossenen Knoten am kleinsten ist. Der kürzeste gefundene Pfad durch einen Zwischenknoten $n$ hat zu jedem Zeitpunkt $i$ immer $f(n)=g_i(n)$. Somit entspricht der A*-Algorithmus ohne zusätzliche Informationen genau dem Dijkstra-Algorithmus aus \ref{Dijkstra_Alg}.
			\item \textbf{$\hat{h}(n)<h(n)$:} Wenn der Abstand eines Knotens $n$ zum Ziel immer unterschätzt wird, also immer kleiner ist als der tatsächliche Abstand, so findet der A*-Algorithmus garantiert den kürzesten Pfad zwischen Start und Ziel. Je kleiner $\hat{h}(n)$ im Verhältnis zu $h(n)$ ist, desto mehr Punkte muss A* expandieren und umso langsamer läuft der Algorithmus.
			\item \textbf{$\hat{h}(n)=h(n)$:} Wenn der geschätzte Abstand eines Knotens genau dem tatsächlichen Abstand entspricht, expandiert A* immer die minimale Anzahl von Knoten entlang des kürzesten Pfades. Das heißt, dass wenn der kürzeste Pfad sechs Knoten enthält, der A*-Algorithmus nur genau sechs Knoten expandiert bevor der Kürzeste Pfad gefunden wurde. Zudem ist der Wert von $f_k(n)$ für jeden Teilknoten $k$ auf dem kürzesten Pfad immer gleich dem exakten Wert des Abstands zwischen Start und Zielknoten.
			\item \textbf{$\hat{h}(n)>h(n)$:} Wenn der geschätzte Abstand eines Knotens größer ist als der tatsächliche Abstand zum Zielknoten, so kann nicht garantiert werden, dass nicht kürzere Pfade zu bereits geschlossenen Knoten existieren.  Somit müssten bereits geschlossene Knoten erneut geöffnet werden um den tatsächlich kürzesten Pfad zu finden. Wird dies nicht getan, so kann der A*-Algorithmus zwar unter Umständen schneller einen Pfad vom Start zum Ziel finden, es ist aber nicht garantiert, dass es sich um den Kürzesten handelt.
			\item \textbf{$\hat{h}(n)\gg h(n)$} Wenn der Schätzwert der Heuristik viel größer ist als der tatsächliche Abstand zum Zielknoten, so ist die Abschätzungsfunktion $f(n)$ nur noch abhängig von $\hat{h}(n)$ und die anderen Terme können vernachlässigt werden. Somit hängt die Reihenfolge der expandierten Knoten nur noch von den Werten der Heuristik der entsprechenden Knoten ab.
		\end{enumerate}
		 
		Anhand der vorgestellten Eigenschaften der Heuristik wird erkennbar, das der A*-Algorithmus durch die Modifizierung der Heuristikberechnung an die gegebenen Anforderungen anpassbar ist. Anstatt einer genauen, aber langsamen Pfadberechnung, kann auf Kosten der Genauigkeit auch schnell ein möglicherweise nicht optimaler Weg zum Ziel gefunden werden. Zudem kann durch perfektes Wissen der Anlage in kürzester Zeit der kürzeste Weg ermittelt werden.
	
	\subsection{Darstellung der Funktionsweise}
		Anhand eines einfachen Beispiels soll jetzt die Funktionsweise des A*-Algorithmus dargestellt werden. Die Knoten des folgenden Graphen sollen Städte darstellen und die Kanten geben die Verbindungen durch Schnellstraßen oder Autobahnen wieder. Als Heuristik wurde hier die Entfernung in Luftlinie zwischen den jeweiligen Städten und der Zielstadt gewählt, da diese die Bedingung $\hat{h}(n)\le h(n)$ erfüllt:
		\\ \textbf{insert graphic here} 

	
	\subsection{Berechnungsaufwand}
		Der Berechnungsaufwand für den A*-Algorithmus lässt sich nur schwer festlegen, da wie in \ref{Heuristik} beschrieben, die Berechnung des kürzesten Pfads sehr stark von der Heuristik abhängt. Unter der Annahme, dass auch wirklich der kürzeste Pfad gefunden wird, muss für die Heuristik gelten:
		\begin{equation} \label{eq:Heuristikbedingung}
			0\le \hat{h}(n)\le h(n)
		\end{equation}
		Somit muss auch der Berechnungsaufwand zwischen dem des Dijkstra-Algorithmus und dem Aufwand im Falle einer exakten Heuristik liegen. Da bei einer exakten Heuristik die Zahl der expandierten Knoten nur von der Anzahl der Knoten auf dem kürzesten Pfad abhängt, ist die Berechnungsaufwand konstant. Daraus folgt für eine beliebige Heuristik, die die Bedingung \ref{eq:Heuristikbedingung} erfüllt:
		\begin{equation}
			\mathcal{O}(\lvert \mathcal{V}\rvert ^2)\ge \mathcal{O}(\hat{h}(n))\ge \mathcal{O}(1)
		\end{equation}
		
		Somit ist der Berechnungsaufwand im schlechtesten Fall quadratisch, im besten Fall aber konstant. Eine bessere Heuristik führt somit dazu, dass weniger Knoten als im schlechtesten Fall expandiert werden müssen und sich somit der Rechenaufwand verringert.
		
	\section{Zusammenspiel der Algorithmen}
		Wie bereits in Abschnitt \ref{Betrachtete_Algorithmen} erwähnt wurde, wird nun ausgenutzt, dass der Dijkstra-Algorithmus die Abstände zu allen betrachteten Knoten im Verlaufe seiner Wegberechnung ermittelt.  Der Nachteil, dass er vergleichsweise langsam arbeitet wird umgangen, indem der Algorithmus nicht in der zeitkritischen zyklischen Bearbeitungsphase sondern beim Hochfahren der CPU ausgeführt wird. Hier ist die Fahrzeugsteuerung\footnote{und vor allem auch der Watchdog-Timer} noch nicht aktiv und somit können auch längere Berechnungen ausgeführt werden. Zusätzlich werden nicht alle Knoten als Startknoten für die Abstandsberechnung mittels Dijkstra verwendet, sondern nur solche, die im späteren Anlagenbetrieb als endgültige Zielknoten für die Wegfindung infrage kommen. Transitknoten, die nur im Verlaufe der Abarbeitung einer Route durchfahren werden, aber an denen nie eine Route endet werden hierbei ausgelassen.\\
		Die Ergebnisse der Dijkstra-Berechnungen werden in einer Tabelle gesichert und als Basis für die Heuristik der Wegfindung mittels A* im Zyklischen Betrieb verwendet. Wie in \ref{Heuristik} gezeigt wurde ist die Anzahl der expandierten Knoten, und somit auch die Laufzeit, minimal wenn als Heuristik der exakte  Abstand zum Ziel genutzt wird. Dieser Fall ist, unter der Bedingung das sich die Anlage seit dem Hochfahren der CPU nur geringfügig geändert hat, durch Verwendung der Abstände aus der Dijkstra-Tabelle des entsprechenden Ziels gegeben. Auch bei Änderungen wie Sperrungen von Kanten oder der Blockade von Teilstrecken durch andere Fahrzeuge erfüllt diese Heuristik noch die Anforderung $\hat{h}(n)<h(n)$, da die neue exakte Route sicher länger ist, als die vorausberechnete Route ohne Sperrungen. Bei Hinzufügen neuer Kanten zur bestehenden Anlage muss die CPU neu gestartet werden, damit die Bedingung aus Gleichung \ref{eq:Heuristikbedingung} in allen Fällen erfüllt ist.
		
		
				





