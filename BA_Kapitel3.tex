\chapter{Theoretische Grundlagen Wegfindung}

\section{Modellierung der Anlagentopologie}
	\label{Graph_Anlage}
	Zur Berechnung eines Weges innerhalb der Anlage wird zuallererst die Topologie der besagten Anlage benötigt. Für die Funktionsweise der \ac{FTF} wurde definiert, das sich alle Fahrzeuge mittels optischer Merkmale auf einer definierten Teilstrecke bewegen. Zudem soll es den Fahrzeugen nur an festgelegten Entscheidungspunkten möglich sein, ihren Fahrzustand zu ändern und eine andere Teilstrecke. Dies bedeutet, das alle Fahrzeuge, sobald sie sich für eine Teilstrecke entschieden haben, dieser bis zum nächsten Entscheidungspunkt folgen. Auf Basis einer solchen logischen Unterteilung der Anlage in Entscheidungspunkte und Teilstrecken als Verbindungen zwischen zwei solcher Punkte, liegt es nahe als Datenstruktur für die Modellierung der Anlagentopologie einen Graphen zu verwenden. Die Entscheidungspunkte entsprechen hierbei den Knoten und die korrespondierenden Teilwegstrecken stellen die Kanten des Graphen dar. Da sich die \ac{FTF} möglichst frei durch die Produktion bewegen sollen, wird als Grundform der Anlage ein ungerichteter Graph zur Abbildung der Topologie verwendet, jedoch soll es für die spätere Wegberechnung unerheblich sein, ob es sich um einen gerichteten oder ungerichteten Graphen handelt.\\
	\textbf{insert graphic about graphs here}\\
	Da der Graph die Abbildung einer realen Anlage kann zudem ausgeschlossen werden das die Gewichtung der Kanten negativ ist, da dies je nach Art der Gewichtung nur wenig Nutzen bringen würde. Es existieren beispielsweise keine negativen Streckenabstände oder Fahrzeiten, die eine spezielle Betrachtung erforderlich machen und somit die Wahl der Wegfindungsalgorithmen einschränken würden.
\section{Dijkstra-Algorithmus}
	Der erste von insgesamt zwei für die Wegfindung verwendeten Algorithmen ist der nach seinem Erfinder benannte Dijkstra-Algorithmus, der den kürzesten Pfad zwischen einem Startknoten und einem Endknoten\footnote{oder allen anderen Knoten.} eines Graphen ermittelt. Er kann verwendet werden für beliebige positiv gewichtete, gerichtete oder ungerichtete Graphen. Da in \ref{Graph_Anlage} negative Kantengewichtungen ausgeschlossen wurden, lässt sich der Algorithmus ohne Abwandlung auf den Graphen der Anlagentopologie anwenden.
	\subsection{Grundprinzip}
		\label{Dijkstra_Alg}
		Das Grundprinzip des Dijkstra-Algorithmus ist Unterteilung aller Graphenknoten in drei Untergruppen\cite{DijkstraAlg}:
		
		\begin{tabular}{p{2.5cm} p{10cm}}	
			\textbf{Gruppe A:} & Die Menge aller Knoten, zu dem bereits ein kürzester Pfad bekannt ist.\\[0.25cm]
			\textbf{Gruppe B:} & Die Menge aller Knoten, die mit mindestens einem Knoten aus Gruppe A verbunden sind, jedoch selbst nicht zu A gehören.\\[0.25cm]
			\textbf{Gruppe C:} & Die Menge der restlichen Knoten, die nicht in den Gruppen A oder B enthalten sind.\\[0.25cm]
		\end{tabular}
		
		Zusätzlich zu den Knoten können auch die Kanten drei unterschiedlichen Teilgruppen zugeordnet werden\cite{DijkstraAlg}:
		
		\begin{tabular}{p{2.5cm} p{10cm}}
			\textbf{Gruppe I:} & Die Menge aller Kanten, die in einem kürzesten Pfad zu einem der Knoten aus Gruppe A vorkommen.\\[0.25cm]
			\textbf{Gruppe II:} & Die Menge aller Kanten, aus denen die nächste Kante für Gruppe I ausgewählt wird, wenn der korrespondierende Knoten aus B zur Gruppe A hinzugefügt wird. Es existiert immer genau eine Kante für jeden Knoten aus Gruppe B. \\[0.25cm]
			\textbf{Gruppe III:} & Die restlichen Kanten.\\[0.25cm]
		\end{tabular}
		
		Der Algorithmus funktioniert nun wie folgt. Zu Beginn befinden sich alle Knoten und Kanten respektive in den Gruppen C oder III. Als erstes wird nun der Startknoten S zu A hinzugefügt, da ein kürzester Pfad vom Startknoten zu sich selbst mit dem Wert 0 bekannt ist. Ab nun werden folgende Schritte solange wiederholt, bis das Ziel erreicht wurde:
		\begin{center}
			\begin{minipage}{0.8\linewidth}

				\begin{enumerate}
					\item Man betrachte alle Kanten \textit{z} die den soeben zu A hinzugefügten Knoten mit einem Knoten \textit{K} aus B oder C verbinden. 
					\begin{itemize}
						\item Gehört \textit{K} zur Gruppe B, so wird untersucht ob \textit{z} zu einem kürzeren Pfad zu \textit{K} führt als der bisherige kürzeste Pfad mit einer Kante aus II zu diesem Knoten. Ist dies der Fall, so ersetzt \textit{z} die korrespondierende Kante aus II. Die Kante die durch \textit{z} wird wieder zur Gruppe III hinzugefügt.
						\item Gehört \textit{K} zur Gruppe  C, so wird \textit{K} zu B und \textit{z} zu II hinzugefügt.
					\end{itemize}
					\item Es existiert immer nur jeweils ein Weg vom Startknoten zu einem beliebigen Knoten von B unter Verwendung der Kanten aus I und II. Nun wird derjenige Knoten aus B zur Gruppe A hinzugefügt, dessen Weg der kürzeste ist. Analog wird die zugehörige Kante der Gruppe I zugeordnet.
				\end{enumerate}
			\end{minipage}
		\end{center}
	\subsection{Darstellung der Funktionsweise}
		Die \textbf{insert graphic here} zeigt die Funktionsweise des Algorithmus an einem einfachen Beispielgraphen mit vier Knoten.
	
	\subsection{Berechnungsaufwand}
		Der Berechnungsaufwand des Dijkstra-Algorithmus beträgt in Landau-Notation vereinfacht $\mathcal{O}(\lvert \mathcal{V}\rvert ^2)$ beziehungsweise $\mathcal{O}(\lvert \mathcal{V}\rvert  \log \lvert \mathcal{V}\rvert + \lvert \mathcal{E}\rvert) $ bei der Implementierung mittels Fibonacci-Heaps\cite{Fredman1984} wobei  $\mathcal{V} $ gleich der Anzahl der Knoten  und $\mathcal{E}$ gleich der Anzahl der Kanten des Graphen ist. diese Vereinfachung gilt jedoch nur, wenn die Anzahl der Kanten in der gleichen Größenordnung liegt wie die Anzahl der Knoten.
	
\section{A*-Algorithmus}
	Der zweite verwendete Algorithmus für die Wegfindung ist der sogenannte A*-Algorithmus. Dieser ist eine Weiterentwicklung des in \ref{Dijkstra_Alg} vorgestellten Dijkstra-Algorithmus. Der grundlegende Unterschied ist jedoch, das bei A* eine Bewertung der Betrachtungsreihenfolge von Knoten bei der Berechnung verwendet werden. Dies bedeutet, dass diejenigen Knoten und Kanten zuerst expandiert werden sollen, bei denen die Wahrscheinlichkeit höher ist, das sie Teil des kürzesten Pfades zum Zielknoten sind. Im Vergleich dazu wurde beim Dijkstra-Algorithmus immer genau der Knoten als nächstes expandiert, der den kürzesten Abstand zu den bereits expandierten Knoten hatte\textbf{Insert graphic dijkstra vs A*}. Um eine Abschätzung der Wahrscheinlichkeit eines Knotens bezüglich seiner Zugehörigkeit zu dem  kürzesten Pfad vom Start zum Zielknoten treffen zu können, werden somit zusätzliche Informationen über die Beziehung zwischen einzelnen Knoten und dem Zielknoten benötigt. Diese Bewertung von Knoten wird auch als Heuristik bezeichnet. Mittels dieser Bewertung kann nun bereits vor Erreichen des Zielknotens eine Aussage über die Länge der Route gemacht werden.
	\subsection{Grundprinzip}
		\label{A*-Alg}
		Die Funktionsweise des A*-Algorithmus kann somit wie folgt als Erweiterung des Dijkstra-Algorithmus beschrieben werden\cite{Hart1968}:
		\begin{center}
			\begin{minipage}{0.8\linewidth}
				\begin{itemize}
					\item \textit{Seien $s$, $n$ und $z$ beliebige Knoten des Graphen $G$, wobei $s$ der Startknoten und $z$ der Zielknoten für die Ermittlung des kürzesten Weges von $s$ zu $z$ sind.}\\
					\item \textit{Sei $f(n)$ eine Funktion zur Abschätzung der Pfadlänge vom Knoten $s$ zum Knoten $z$, welcher den Knoten $n$ beinhält.}
				\end{itemize}
		
				\begin{enumerate}
					\item Man markiere $s$ als "`offen"' und berechne $f(s)$.
					\item Man wähle denjenigen offenen Knoten $n$ aus, der den  kleinsten Wert für $f(n)$ besitzt.
					\item Falls $n=z$, wird $n$ als "`geschlossen"' markiert und beende den Algorithmus.
					\item Andernfalls markiere man $n$ als "`geschlossen"' und füge alle von $n$ erreichbaren Knoten $n'$ zur Liste der offenen Knoten hinzu, die noch nicht als geschlossen markiert wurden und berechne $f(n')$. 	Man springe zurück zu Schritt 2.
				\end{enumerate}
			\end{minipage}
		\end{center}
		
		Man sieht das somit bei dem A*-Algorithmus diejenigen Knoten bevorzugt betrachtet werden, die durch die Abschätzungsfunktion als "`wahrscheinlicher zum Ziel führend"' bewertet wurden. Somit ist es nur sinnvoll diesen Bewertungsvorgang näher zu betrachten. 
		
	
	
	
	\subsection{Abschätzungsfunktion $f(n)$}
		Die Abschätzungsfunktion, die in \ref{A*-Alg} definiert wurde, kann unterteilt werden in zwei Unterfunktionen\cite{Hart1968}:
		\begin{equation}
			f(n)=g(n)+h(n)
		\end{equation}
		
		$g(n)$ beschreibt hierbei den Wert des kürzesten Pfads von $s$ zu $n$ und $h(n)$ beschreibt den Wert des Pfades von $n$ zum Ziel $z$.
		
		Da die genauen Werte für $g(n)$ und $f(n)$ im Verlauf der Berechnung aber möglicherweise noch nicht exakt bestimmbar sind \footnote{exakt bestimmbar sind diese erst wirklich beim erreichen des Zielknotens $z$ und sukzessivem Beenden des Algorithmus.}, werden Schätzwerte für $g(n)$ und $h(n)$ verwendet. Sei somit $\hat{g}(n)$ der Wert des bisher gefundenen kürzesten Pfads von $s$ zu $n$ und sei $\hat{h}(n)$ der Wert der Heuristik des Pfads von $n$ zum Ziel $z$ so folgt als Abschätzung für $f(n)$
		\begin{equation}
			\hat{f}(n)=\hat{g}(n)+\hat{h}(n)
		\end{equation}
		
		Man kann nun beweisen das für alle Knoten $n$, die als offen markiert sind gilt:
		\begin{equation}
			\hat{g}(n)=g(n)
		\end{equation}
		Da davon ausgegangen werden kann, das alle Pfade $g(k_i)$ für bereits geschlossene Knoten $k$ bekannt und minimal sind und somit auch gilt\footnote{analog zu \ref{Dijkstra_Alg} Schritt 2 mit $v_{k,n}$ als die Gewichtung der Kante zwischen den Knoten $k$ und $n$.}
		\begin{equation}
			\hat{g}(n)=g(k_i)+min(v_{k_i,n})=g(n)
		\end{equation}
		 muss nur noch die Heuristik $\hat{h}(n)$ definiert werden.
		 Es kann bewiesen werden, das der A*-Algorithmus konsistent ist, das heißt, dass jeder bereits geschlossene Knoten nicht erneut geöffnet werden muss, wenn gilt:
		 \begin{equation}
			 \hat{h}(n)\le h(n).
		 \end{equation}
		 Für die Berechnung bedeutet dies, dass wir den Wert des Restpfades von $n$ zu dem Zielknoten $z$ durch die Heuristik zwar unterschätzen dürfen, falls wir aber für die Berechnung einen möglichst effizienten Algorithmus benötigen, wir die Heuristik auf keinen Fall überschätzen dürfen.
		
		
		
	
	\subsection{Vergleich verschiedener Heuristiken $h(n)$}
		\cite{Patel2016}
	
	\subsection{Darstellung der Funktionsweise}
	

	
	\subsection{Berechnungsaufwand}
	

	
\section{Alternative D* / D*-Lite}
\cite{DStarAlg}
\cite{Koenig2005}



