\chapter{Theoretische Grundlagen Wegfindung}
	\label{Theorie}
\section{Modellierung der Anlagentopologie}
	\label{Graph_Anlage}
	Zur Berechnung eines Weges innerhalb der Anlage wird zunächst die Topologie der besagten Anlage benötigt. Für die Funktionsweise der \ac{FTF} wurde definiert, dass sich alle Fahrzeuge mittels optischer Merkmale auf einer definierten Teilstrecke bewegen. Zudem soll es den Fahrzeugen nur an festgelegten Entscheidungspunkten möglich sein, ihren Fahrzustand zu ändern und eine andere Teilstrecke auszuwählen. Dies bedeutet, dass alle Fahrzeuge, sobald sie sich für eine Teilstrecke entschieden haben, dieser bis zum nächsten Entscheidungspunkt folgen. Auf Basis einer solchen logischen Unterteilung der Anlage in Entscheidungspunkte und Teilstrecken als Verbindungen zwischen zwei solcher Punkte, liegt es nahe als Datenstruktur für die Modellierung der Anlagentopologie einen Graphen zu verwenden. Die Entscheidungspunkte entsprechen hierbei den Knoten und die korrespondierenden Teilwegstrecken stellen die Kanten des Graphen dar. Da sich die \ac{FTF} möglichst frei durch die Produktion bewegen sollen, wird als Grundform der Anlage ein ungerichteter Graph zur Abbildung der Topologie verwendet, jedoch soll es für die spätere Wegberechnung unerheblich sein, ob es sich um einen gerichteten oder ungerichteten Graphen handelt.\\
	\textbf{insert graphic about graphs here}\\
	Da der Graph die Abbildung einer realen Anlage ist, kann zudem ausgeschlossen werden, dass die Gewichtung der Kanten negativ ist, da dies je nach Art der Gewichtung nur wenig Nutzen bringen würde. Es existieren beispielsweise keine negativen Streckenabstände oder Fahrzeiten, die eine spezielle Betrachtung erforderlich machen und somit die Wahl der Wegfindungsalgorithmen einschränken würden.
	
\section{Auswahl der Algorithmen}

	Es existieren mehrere Algorithmen, welche sich mit der Problemstellung der Berechnung eines kürzesten Pfads zwischen zwei Knoten eines gewichteten Graphen befassen. Um eine passende Vorgehensweise auswählen zu können muss zuerst definiert werden, welche Kriterien ein potentieller Wegfindungsalgorithmus erfüllen muss.
	
	\subsection{Auswahlkriterien}
		\label{Kriterien_Alg}
		Für ein geeignetes Wegfindungssystem müssen die folgenden Aspekte berücksichtigt werden:
		\begin{enumerate}
			\item Die Berechnung soll auf einer \ac{SPS} des niedrigen Leistungssegments durchgeführt werden. Somit müssen die daraus resultierenden Beschränkungen bezüglich Komplexität und Speicherbedarf erfüllt sein.
			\item Eine \ac{SPS} ist ein Echtzeitsystem, welches das Programm zyklisch abarbeitet. Gleichzeitig wird auf der Steuerung auch die Fahraufgabe realisiert. Dadurch muss die Rechenzeit kurz genug sein, um eine Reaktionsfähigkeit des Fahrprogramms sicherstellen zu können.
			\item Die Wegfindung soll während der Ausführung eines vorausberechneten Fahrauftrags auf andere Fahrzeuge oder Änderungen der Anlagentopologie reagieren können.
			\item Es soll ein optimaler Weg gefunden werden. Optimal bedeutet im vorliegenden Fall einen möglichst kurzen Weg zum Zielknoten.
			\item Die Anlage soll gleichmäßig ausgelastet sein in Bezug auf Bearbeitungsstationen mit gleicher Funktionalität.
		\end{enumerate}
		
		Eine \ac{SPS}, wie sie in Punkt 1 beschrieben wird, erlaubt nur eine geringe Schachtelungstiefe der Unterprogrammaufrufe. Die verwendeten Steuerungen der S7-1200er Reihe erlauben beispielsweise eine Schachtelungstiefe von maximal 16 Bausteinaufrufen aus zyklischen und Anlauf-Bausteinen heraus \cite{S7-1200}.  Da diese kleinen \ac{SPS} zudem über stark begrenzten Speicherplatz verfügen, muss bei einer Implementierung  mittels Stack überprüft werden, dass der hierfür statisch allozierte Speicherbereich auf der Steuerung zur Verfügung steht. Dies beschränkt den Einsatz von rekursiven Algorithmen jedoch auf Anwendungen, bei denen die Anzahl der Rekursionen von vornherein bekannt ist. Ein weiterer Nachteil von Rekusrsion ist, dass das Zeitverhalten von rekursiven Bausteinaufrufen nur schwer abschätzbar ist, und somit vorgegebene harte Echtzeitbedingungen des Systems verletzt werden können. Da die Anlagen aber beliebiger Art sein sollen, können Algorithmen die Rekursion verwenden somit nicht generell genutzt werden. Zudem fallen für die Implementierung diejenigen Algorithmen heraus, die nur sehr umständlich in der begrenzten Programmierumgebung für Echtzeitsteuerungen realisiert werden können.\\
		Die Einhaltung der in Punkt 2 beschriebenen Echtzeitbedingung ist keine generelle Frage des Algorithmus sonder eine Sache der Implementierung. Hier müssen Programmteile mit Schleifenkonstrukten möglicherweise aufgebrochen und die Berechnung auf verschiedene Zyklen aufgeteilt werden.\\
		Die in Punkt 3 erwähnte Reaktionsfähigkeit erfordert von den Algorithmen, dass sie auch in nur teilweise bekannten Umgebungen sicher einen Weg finden können. Für das Zusammenspiel ist eine Methode für die Vorhersage der Positionen anderer Fahrzeuge notwendig.\\
		Da aus Gründen der Anlageneffizienz die Laufzeit eines Werkstücks durch die Anlage möglichst minimiert werden soll, wird von dem Wegfindungsalgorithmus gemäß Punkt 4 erwartet, dass er nicht nur schnell einen möglichen Weg findet, sondern dass der gefundene Weg auch der kürzeste, mit den begrenzten Anlageninformationen\footnote{ Abschnitt \ref{Zeitproblem} erläutert, dass Bewegungen anderer Fahrzeuge nur begrenzt vorausberechnet werden können.} berechenbare, Pfad zum Zielknoten ist.\\
		Da die im Punkt 5 erwähnte gleichmäßige Auslastung mehr mit der Auswahl des geeigneten Zielknotens als mit der eigentlichen Wegfindung zu tun hat, ist diese Anforderung nur begrenzt für die Auswahl der Algorithmen von Bedeutung.
		
	\subsection{Betrachtete Algorithmen}
		\label{Betrachtete_Algorithmen}
		Im Angesicht der in \ref{Kriterien_Alg} ermittelten Auswahlkriterien wurden die folgenden Algorithmen näher betrachtet:
		
		\begin{longtable}{p{2.5cm} p{10cm}}
			
			\textbf{Dijkstra :} & Einer der Grundalgorithmen für das Kürzeste-Pfad-Problem, bei dem auch die kürzesten Entfernungen aller Knoten zu einem Startknoten ermittelt werden können.\\[0.5cm]
			\textbf{A* :} & Eine Abwandlung des Dijkstra-Algorithmus, bei dem die Anzahl der betrachteten Knoten verringert werden kann, indem Zusatzinformationen in Form einer Heuristik als Entscheidungshilfe für die Betrachtungsreihenfolge verwendet werden.\\[0.5cm]
			\textbf{\ac{MA*}\cite{Chakrabarti1989}:} &	Dieser Algorithmus beschränkt den Speicherverbrauch indem er den Topologiegraphen in Teilbäume unterteilt und nur erfolgversprechende Knoten und Teilgraphen im Speicher behält.\\[0.5cm]
			\textbf{\ac{RTA*}\cite{Korf1990}:} & Dieser Algorithmus unterteilt den Hauptalgorithmus in  Planungs- und Ausführungsphasen und beschränkt die Anzahl der betrachteten Knoten anhand einer Alpha-Beta-Suche. Durch diese Unterteilung kann ein gewisses Maß an Dynamik gewonnen werden, da der Algorithmus nach jeder Ausführungsphase die Restroute neu evaluiert und gegebenenfalls die aktuelle Route gegen einen neuen optimierten Weg ersetzt.\\[0.5cm]
			\textbf{\ac{D*}\cite{DStarAlg}\cite{Koenig2005}:} & Dieser Algorithmus wurde entwickelt für Topologien, welche nur teilweise bekannt sind, beziehungsweise die sich dynamisch verändern können. Zeiger die entlang des jeweils kürzesten Weges vom aktuellen Knoten zum Startknoten zeigen werden bei Anlagenänderung durch sogenannte "`Modify-Cost-Operationen"' ausgehend von der Anlagenänderung kaskadierend modifiziert bis sich ein neuer statischer Zustand eingestellt hat. Die Wegberechnung nutzt diese Zeiger zur schnelleren Berechnung des kürzesten Pfades.\\[0.5cm]
			
		\end{longtable}
		
		Der Dijkstra-Algorithmus ist aufgrund seiner langen Berechnungszeit ungeeignet, für die Wegfindung im laufenden Betrieb der \ac{FTF} jedoch kann ausgenutzt werden, dass bei der Berechnung des kürzesten Pfades via Dijkstra die Abstände aller besuchten Knoten zum Startknoten ermittelt werden. Diese Abstände bilden die Basis zur Verbesserung der bei einem der anderen Algorithmen genutzten Heuristiken. Die Algorithmen \ac{MA*}, \ac{RTA*} und \ac{D*} sind alle Weiterentwicklungen des A*-Algorithmus. Die zu entwickelnde Modellanlage besitzt im vorliegenden Fall nur eine begrenzte Anzahl von Knoten. Dadurch ist der Nachteil des hohen Speicherbedarfs des Grundalgorithmus A* hier vernachlässigbar und der zusätzliche Aufwand für die Implementierung von \ac{MA*} zunächst ignoriert werden. Bei realen Anlagen mit einer höheren Anzahl an Knoten muss jedoch im Einzelfall betrachtet werden, ob eine Steuerung mit größerem Arbeitsspeicher oder die Implementierung des \ac{MA*}-Algorithmus notwendig ist. Der \ac{D*}-Algorithmus wurde wegen seiner höheren Komplexität und der Beschränkungen durch die Programmierumgebung nicht implementiert. Als zyklischer Wegfindungsalgorithmus wurde eine Mischform des A*-Algorithmus mit der Planungs- und Ausführungsaspekten ähnlich denen von \ac{RTA*} verwendet, indem in regelmäßigen Abständen der bisher gefundene Teilweg verifiziert und bei Bedarf neu berechnet wird. Die verwendeten Algorithmen sollen nun etwas näher betrachtet werden.

\section{Gemeinsamkeiten der Algorithmen}

	Aufgrund der Tatsache, dass es sich bei dem A*-Algorithmus um eine Weiterentwicklung des Dijkstra-Algorithmus handelt, gibt es einige Grundprinzipien, die bei von beiden Algorithmen verwendet werden. Zum einen arbeiten beide mit einer Unterteilung der Graphenknoten in Unterklassen mit definierten Eigenschaften. Zum anderen wählen die Algorithmen den Knoten, der als nächstes betrachtet wird, nach bestimmten Kriterien aus. Bevor die Algorithmen einzeln vorgestellt werden, sollen zunächst ihre Gemeinsamkeiten dargestellt werden.
	
	\subsection{Klassifizierung der Knoten}
		\label{Klassifizierung}
		Um einen kürzesten Pfad zwischen zwei Knoten eines Graphen zu ermitteln, ist es hilfreich,während der Pfadberechnung alle Knoten des Graphen in drei Klassen aufzuteilen \cite{DijkstraAlg}:
		
		\begin{longtable}{p{2.5cm} p{10cm}}	
			\textbf{Klasse A:} & Die Menge aller Knoten, zu denen bereits ein kürzester Pfad  vom Startknoten aus bekannt ist. Diese Klasse wird auch als Closed-List bezeichnet.\\[0.25cm]
			\textbf{Klasse B:} & Die Menge aller Knoten, die mit mindestens einem Knoten aus Gruppe A verbunden sind, jedoch selbst nicht zu A gehören. Diese Klasse wird auch als Open-List bezeichnet.\\[0.25cm]
			\textbf{Klasse C:} & Die Menge der restlichen Knoten, die nicht in den Gruppen A oder B enthalten sind, und somit noch nicht betrachtet wurden.\\[0.25cm]
		\end{longtable}
		
		Analog können auch die Kanten des Graphen klassifiziert werden.
	
		\begin{longtable}{p{2.5cm} p{10cm}}
			\textbf{Klasse I:} & Die Menge aller Kanten, die in einem kürzesten Pfad zu einem der Knoten aus Gruppe A vorkommen.\\[0.25cm]
			\textbf{Klasse II:} & Die Menge aller Kanten, aus denen die nächste Kante für Gruppe I ausgewählt wird, wenn der korrespondierende Knoten aus B zur Gruppe A hinzugefügt wird. Es existiert immer genau eine derartige Kante für jeden Knoten aus Gruppe B. \\[0.25cm]
			\textbf{Klasse III:} & Die restlichen Kanten, die sich nicht in den Klassen I und II befinden.\\[0.25cm]
		\end{longtable}
		
		Eine derartige Einteilung der Knoten vereinfacht während der Berechnung des kürzesten Pfades die Entscheidung, welche Knoten momentan für die Wegfindung interessant sind und somit näher betrachtet werden sollten.
		
	\subsection{Auswahl des nächsten Knotens}
		\label{Abschaetz}
		Da nun die interessanten Knoten des Graphen identifiziert wurden, stellt sich die Frage in welcher Reihenfolge diese Knoten am besten betrachtet werden sollten.
		Diese Reihenfolge kann mittels einer Entscheidungsfunktion $f(n)$ bestimmt werden.
		
		\begin{itemize}
			\item \textit{Seien $s$, $n$ und $z$ beliebige Knoten des Graphen $G$, wobei $s$ der Startknoten und $z$ der Zielknoten für die Ermittlung des kürzesten Weges von $s$ zu $z$ sind.}\\
			\item \textit{Sei $f(n)$ der Wert eines kürzesten Pfades vom Knoten $s$ zum Knoten $z$, der zusätzlich den Knoten $n$ enthält.}
		\end{itemize}
		
		Es sei zunächst nicht bekannt, ob der Knoten $n$ auch auf dem kürzesten Pfad von $s$ nach $z$ liegt.
		Diese Entscheidungsfunktion, kann unterteilt werden in zwei Unterfunktionen $g(n)$ und $h(n)$ für die gilt \cite{Hart1968}:
		\begin{equation}
		f(n)=g(n)+h(n)
		\end{equation}
		
		Die Funktion $g(n)$ liefert hierbei den Wert des kürzesten Pfads vom Knoten $s$ zu $n$. Die Funktion $h(n)$ beschreibt den Wert eines kürzesten Pfades von $n$ zum Ziel $z$. A priori\footnote{also bevor der Wert von $f(n)$ bestimmt wurde.} sind die exakten Werte für $g(n)$ und $h(n)$ aber möglicherweise noch nicht bekannt. Somit werden für die Berechnung zunächst Schätzwerte für $g(n)$ und $h(n)$ verwendet. Sei also $\hat{g}(n)$ der Wert des bisher gefundenen kürzesten Pfades von $s$ nach $n$ und sei $\hat{h}(n)$ der mittels einer Heuristik geschätzte Wert des kürzesten Pfads von $n$ nach $z$. Somit kann der Wert von $f(n)$ geschätzt werden durch:
		\begin{equation}
			\hat{f}(n)=\hat{g}(n)+\hat{h}(n)
		\end{equation}
	
		Man geht zunächst davon aus, dass sich $n$ in der Klasse B befindet. $s$ befindet sich per Definition des Startknotens bereits in A, da die Entfernung von $s$ zu $s$ gleich null ist. Gemäß der Definition der Klasse B existiert somit mindestens ein Knoten $k_i$ aus der Klasse A, der durch eine Kante mit dem Knoten $n$ verbunden ist und für den der $g(k_i)$ bereits bestimmt wurde\footnote{dies ist durch die Definition von A gegeben.}. Sei $v_{k_i,n}$ die Gewichtung der Verbindungskante des Knotens $k_i$ nach $n$, so kann der exakte Wert für $g(n)$ wie folgt bestimmt werden:
		\begin{equation}
			\hat{g}(n)=g(k_i)+min(v_{k_i,n})=g(n)
		\end{equation}
		
		Dadurch kann der exakte Wert für $g(n)$ bestimmt werden. Die Kante mit der kleinsten Gewichtung, die den Knoten $n$ mit einem Knoten $k_i$ aus A verbindet, gehört zu der in Abschnitt \ref{Klassifizierung} definierten Klasse II.\\
		Es kann beweisen werden \cite{Hart1968}, das die Wegfindungsalgorithmen immer den kürzesten Pfad von $s$ nach $z$ finden, sollte dieser existieren, wenn die Heuristik "`zulässig"' ist. Eine zulässige Heuristik, ist eine Schätzung deren Wert kleiner ist als der tatsächliche Wert, der geschätzt werden soll. Im vorliegenden Fall bedeutet dies, dass gelten muss:
		\begin{equation}
			\hat{h}(n)\le h(n).
		\end{equation}
		
		Dies hat zur Folge, dass der kürzeste Pfad von $s$ nach $z$ unter Verwendung einer solchen Heuristik $\hat{h}(n)$ bei Beendigung des Algorithmus nur aus Knoten der Klasse A besteht, also keine anderer Pfad existiert, der kürzer ist als der gefundene. Durch Speicherung des jeweiligen Vorgängers des aktuellen Knotens kann nach Beendigung der Algorithmen der kürzeste Pfad konstruiert werden. 
		\\
		Der Dijkstra-Algorithmus stellt hier den Standardfall dar, bei dem $\hat{h}(n)=0$ angenommen wird. Im Bezug auf A* werden unterschiedliche Werte für die Heuristik in Abschnitt \ref{Heuristik} näher betrachtet.
	
\section{Dijkstra-Algorithmus}
	Der erste für die Wegfindung verwendeten Algorithmus ist wie bereits erwähnt, der nach seinem Erfinder benannte Dijkstra-Algorithmus, der den kürzesten Pfad zwischen einem Startknoten und einem Endknoten\footnote{oder allen anderen Knoten.} eines Graphen ermittelt. Er kann verwendet werden für beliebige positiv gewichtete, gerichtete oder ungerichtete Graphen. Da in Abschnitt \ref{Graph_Anlage} negative Kantengewichtungen ausgeschlossen wurden, lässt sich der Algorithmus ohne Abwandlung auf den Graphen der Anlagentopologie anwenden.
	\subsection{Grundprinzip}
		\label{Dijkstra_Alg}
		
		Der Algorithmus funktioniert wie folgt. Zu Beginn befinden sich alle Knoten und Kanten respektive in den Klassen C oder III, da sie noch nicht betrachtet wurden. Als erstes wird der Startknoten S zur Klasse A hinzugefügt, da ein kürzester Pfad vom Startknoten zu sich selbst mit der Entfernung null bekannt ist. Der Startknoten kann somit als geschlossen angesehen werden. Nun werden folgende Schritte solange wiederholt, bis der Zielknoten erreicht wurde:
		\begin{center}
			\begin{minipage}{0.8\linewidth}

				\begin{enumerate}
					\item Man betrachte alle Kanten \textit{z} die den soeben zu A hinzugefügten Knoten mit einem Knoten \textit{K} aus B oder C verbinden. 
					\begin{itemize}
						\item Gehört \textit{K} bereits zur Gruppe B, so wird untersucht ob die Kante \textit{z} zu einem kürzeren Pfad zu \textit{K} führt, als der bisher gefundene kürzeste Pfad. Ist dies der Fall, so ersetzt \textit{z} die korrespondierende Kante aus II. Die Kante die durch \textit{z} ersetzt wird, wird wieder zur Gruppe III hinzugefügt.
						\item Gehört \textit{K} zur Gruppe  C, so wird \textit{K} zu B und \textit{z} zu II hinzugefügt.
					\end{itemize}
					\item Es wird die in Abschnitt \ref{Abschaetz} vorgestellte Funktion $f(n)$ verwendet, um genau den Knoten $B_i$ in der Klasse B zu finden, der den kleinsten Wert für $f(B_i)$ besitzt. Da bei dem Dijkstra-Algorithmus $\hat{h}(n)$ gleich null ist, wird genau der Knoten  $B_i$ ausgewählt, für den $g(B_i)$ den kleinsten Wert hat, der also von den offenen Knoten den kleinsten Abstand zum Startknoten hat. Die zu $B_i$ gehörende Kante aus II wechselt damit in die Klasse I.
				\end{enumerate}
				
			\end{minipage}
		\end{center}
	\subsection{Darstellung der Funktionsweise}
		Die \textbf{insert graphic here} zeigt die Funktionsweise des Algorithmus an einem einfachen Beispielgraphen mit vier Knoten.
	
	\subsection{Berechnungsaufwand}
		Der Berechnungsaufwand des Dijkstra-Algorithmus beträgt in Landau-Notation vereinfacht $\mathcal{O}(\lvert \mathcal{V}\rvert ^2)$, beziehungsweise $\mathcal{O}(\lvert \mathcal{V}\rvert  \log \lvert \mathcal{V}\rvert + \lvert \mathcal{E}\rvert) $ bei der Implementierung mittels Fibonacci-Heaps \cite{Fredman1984}, wobei  $\lvert \mathcal{V}\rvert$ gleich der Anzahl der Knoten  und $\lvert \mathcal{E}\rvert$ gleich der Anzahl der Kanten des Graphen ist. Diese Vereinfachung gilt jedoch nur, wenn die Anzahl der Kanten in der gleichen Größenordnung liegt wie die Anzahl der Knoten, also beispielsweise nicht für vollständige graphen, für die gilt $\lvert \mathcal{E}\rvert =\mathcal{O}(\lvert \mathcal{V}\rvert ^2)$.
	
\section{A*-Algorithmus}
	Der zweite verwendete Algorithmus für die Wegfindung ist der sogenannte A*-Algorithmus. Dieser ist eine Weiterentwicklung des in \ref{Dijkstra_Alg} vorgestellten Dijkstra-Algorithmus. Der grundlegende Unterschied ist jedoch, dass bei A* eine andere Bewertung der Betrachtungsreihenfolge von Knoten bei der Berechnung verwendet werden. Dies bedeutet, dass diejenigen Knoten und Kanten zuerst expandiert werden sollen, bei denen die Wahrscheinlichkeit höher ist, das sie Teil des kürzesten Pfades zum Zielknoten sind. Im Vergleich dazu wurde beim Dijkstra-Algorithmus immer genau der Knoten aus B als nächstes expandiert, der den kürzesten Abstand zu dem Startknoten hatte\textbf{Insert graphic dijkstra vs A*}. Um eine Abschätzung der Wahrscheinlichkeit eines Knotens bezüglich seiner Zugehörigkeit zu dem  kürzesten Pfad vom Start zum Zielknoten treffen zu können, werden somit zusätzliche Informationen über die Beziehung zwischen einzelnen Knoten und dem Zielknoten benötigt. Diese Bewertung von Knoten ist die im Abschnitt \ref{Abschaetz} vorgestellte Heuristik bezeichnet. Mittels dieser Bewertung kann nun bereits vor Erreichen des Zielknotens eine Aussage über die Länge der Route gemacht werden. 
	
	\subsection{Grundprinzip}
		\label{A*-Alg}
		Die Funktionsweise des A*-Algorithmus kann somit als Erweiterung des Dijkstra-Algorithmus beschrieben werden \cite{Hart1968}. Unter Verwendung der in Abschnitt \ref{Abschaetz} definierten Entscheidungsfunktion kann wie folgt verfahren werden:
		
		\begin{itemize}
			 \item 	$s$, $z$ und $n$ sind Knoten eines Graphen. Es soll der kürzeste Pfad von $s$ nach $z$ ermittelt werden. 
			
		\end{itemize}
		
		\begin{center}
			
			\begin{minipage}{0.8\linewidth}
				
				
				\begin{enumerate}
					\item Man markiere $s$ als "`offen"' und berechne $f(s)$.
					\item Man wähle für $n$ denjenigen Knoten aus der Open-List aus, der den  kleinsten Wert für $f(n)$ besitzt.
					\item Falls $n=z$, wird $n$ als "`geschlossen"' markiert und der Algorithmus beendet.
					\item Andernfalls markiere man $n$ als "`geschlossen"' und füge alle von $n$ über maximal eine Kante erreichbaren Knoten $n'$ zur Liste der offenen Knoten hinzu, die noch nicht als geschlossen markiert wurden und berechne $f(n')$. 	Man springe zurück zu Schritt 2.
				\end{enumerate}
			\end{minipage}
		\end{center}
		
		Anhand dieser Vorgehensweise ist zu erkennen, dass bei dem A*-Algorithmus diejenigen Knoten bevorzugt betrachtet werden, die durch die Entscheidungsfunktion als "`wahrscheinlicher zum Ziel führend"' bewertet wurden, da anders als bei Dijkstra $\hat{h}(n)$ bei der Berechnung von $f(n)$ einen Einfluss auf das Ergebnis hat. Somit ist es sinnvoll diesen Bewertungsvorgang näher zu betrachten. 
		
	\subsection{Vergleich verschiedener Heuristiken h(n)}
		\label{Heuristik}
		Die in Kapitel \ref{Abschaetz} besprochene Entscheidungsfunktion $f(n)$ und diesbezüglich vor allem auch der Wert von $\hat{h}(n)$ haben einen großen Einfluss auf das Verhalten des A*-Algorithmus.
		Zur Veranschaulichung sollen einige Möglichkeiten für diese Heuristik betrachtet werden \cite{Patel2016}:
		\begin{enumerate}
			\item \textbf{$\hat{h}(n)=0$:} Wenn der Wert der Heuristik konstant auf Null gesetzt wird, so ist dies gleich zu setzen damit, als würden keine Zusatzinformationen zur Berechnung der Route verwendet. Dies bedeutet das immer genau der Knoten aus der Menge von offenen Punkten ausgewählt wird, dessen Abstand zum Startknoten am kleinsten ist. Der kürzeste gefundene Pfad durch einen Zwischenknoten $n$ hat zu jedem Zeitpunkt $i$ immer $f_i(n)=g_i(n)$. Somit entspricht der A*-Algorithmus mit der Heuristik $\hat{h}(n)=0$ genau dem Dijkstra-Algorithmus aus \ref{Dijkstra_Alg}.
			
			\item \textbf{$\hat{h}(n)<h(n)$:} Wenn der Abstand eines Knotens $n$ zum Ziel immer unterschätzt wird, also immer kleiner ist als der tatsächliche Abstand, so findet der A*-Algorithmus, wie bereits im Abschnitt \ref{Abschaetz} gezeigt, garantiert den kürzesten Pfad zwischen Start und Ziel. Je kleiner $\hat{h}(n)$ im Verhältnis zu $h(n)$ ist, desto mehr Knoten muss A* expandieren und umso langsamer läuft der Algorithmus.
			
			\item \textbf{$\hat{h}(n)=h(n)$:} Wenn der geschätzte Abstand eines Knotens genau dem tatsächlichen Abstand entspricht, expandiert A* immer die minimale Anzahl von Knoten entlang des kürzesten Pfades. Das heißt, dass wenn der kürzeste Pfad sechs Knoten enthält, der A*-Algorithmus nur genau sechs Knoten expandiert bevor der Zielknoten geschlossen und somit der kürzeste Pfad gefunden wurde. Zudem ist der Wert von $f_k(n)$ für jeden Teilknoten $k$ auf dem kürzesten Pfad immer gleich dem exakten Wert des Abstands zwischen Start und Zielknoten.
			
			\item \textbf{$\hat{h}(n)>h(n)$:} Wenn der geschätzte Abstand eines Knotens größer ist als der tatsächliche Abstand zum Zielknoten, so kann nicht mit Bestimmtheit gesagt werden, dass kein kürzerer Pfad zu bereits geschlossenen Knoten existieren.  Somit müssten, um den möglicherweise existierenden tatsächlichen kürzesten Pfad zu finden, bereits geschlossene Knoten erneut geöffnet werden. Wird dies nicht getan, so kann der A*-Algorithmus zwar unter Umständen schneller einen Pfad vom Start zum Ziel finden, es ist aber nicht garantiert, dass es sich um den Kürzesten handelt.
			
			\item \textbf{$\hat{h}(n)\gg h(n)$} Wenn der Schätzwert der Heuristik viel größer ist als der tatsächliche Abstand zum Zielknoten, so ist die Entscheidungsfunktion $f(n)$ nur noch abhängig von $\hat{h}(n)$ und die anderen $g(n)$ kann vernachlässigt werden. Somit hängt die Reihenfolge der expandierten Knoten nur noch von den Werten der Heuristik der entsprechenden Knoten ab.
		\end{enumerate}
		 
		Anhand der vorgestellten Eigenschaften der Heuristik wird erkennbar, das der A*-Algorithmus durch die Modifizierung der Heuristikberechnung an die gegebenen Anforderungen anpassbar ist. Anstatt einer genauen, aber langsamen Pfadberechnung, kann auf Kosten der Genauigkeit auch schnell ein möglicherweise nicht optimaler Weg zum Ziel gefunden werden. Zudem kann durch perfektes Wissen der Topologie der Anlage in kürzester Zeit der kürzeste Weg ermittelt werden.
	
	\subsection{Darstellung der Funktionsweise}
		Anhand eines einfachen Beispiels soll jetzt die Funktionsweise des A*-Algorithmus dargestellt werden. Die Knoten des folgenden Graphen sollen Städte darstellen und die Kanten geben die Verbindungen durch Schnellstraßen oder Autobahnen wieder. Die Gewichtungen der Kanten stellen in diesem Beispiel die Entfernungen zwischen den Städten dar. Als Heuristik wurde hier die Entfernung in Luftlinie zwischen den jeweiligen Städten und der Zielstadt gewählt, da diese die Luftlinie immer kürzer\footnote{oder im Extremfall gleich lang.} ist als eine Straße zwischen den Städten und somit die Bedingung $\hat{h}(n)\le h(n)$ erfüllt ist:
		\\ \textbf{insert graphic here} 

	
	\subsection{Berechnungsaufwand}
		\label{Aufwand_A*}
		Der Berechnungsaufwand für den A*-Algorithmus lässt sich nur schwer festlegen, da wie in \ref{Heuristik} beschrieben, die Berechnung des kürzesten Pfads sehr stark von der Heuristik abhängt. Unter der Annahme, dass auch wirklich der kürzeste Pfad gefunden wird, muss für die Heuristik gelten:
		\begin{equation} \label{eq:Heuristikbedingung}
			0\le \hat{h}(n)\le h(n)
		\end{equation}
		Somit muss auch der Berechnungsaufwand zwischen dem des Dijkstra-Algorithmus und dem Aufwand im Falle einer exakten Heuristik liegen. Da bei einer exakten Heuristik die Zahl der expandierten Knoten nur von der Anzahl der Knoten auf dem kürzesten Pfad abhängt, ist die Berechnungsaufwand konstant. Daraus folgt für eine beliebige Heuristik, die Bedingung \ref{eq:Heuristikbedingung} erfüllt:
		\begin{equation}
			\mathcal{O}(\lvert \mathcal{V}\rvert ^2)\ge \mathcal{O}(\hat{h}(n))\ge \mathcal{O}(\lvert \mathcal{V}\rvert)
		\end{equation}
		
		Somit ist der Berechnungsaufwand im schlechtesten Fall quadratisch, im besten Fall aber gleich der Anzahl der Knoten des kürzesten Pfads. Eine bessere Heuristik führt somit dazu, dass weniger Knoten als im schlechtesten Fall expandiert werden müssen und sich somit der Rechenaufwand verringert.
		
	\section{Zusammenspiel der Algorithmen}
		\label{Verwendung_Alg}
		Wie bereits in Abschnitt \ref{Betrachtete_Algorithmen} erwähnt, wird nun ausgenutzt, dass der Dijkstra-Algorithmus die Abstände vom Startknoten zu allen betrachteten Knoten ermittelt.  Der Nachteil, dass er vergleichsweise langsam arbeitet wird umgangen, indem der Algorithmus nicht in der zeitkritischen zyklischen Bearbeitungsphase sondern beim Hochfahren der CPU ausgeführt wird. Hier ist die Fahrzeugsteuerung\footnote{und vor allem auch der Watchdog-Timer} noch nicht aktiv und somit können auch längere Berechnungen ausgeführt werden. Zusätzlich werden nicht alle Knoten als Startknoten für die Abstandsberechnung mittels Dijkstra verwendet, sondern nur solche, die im späteren Anlagenbetrieb als endgültige Zielknoten für die Wegfindung infrage kommen.Als solche Zielknoten kommen allem die Knoten in Frage, an denen sich Maschinen befinden oder die eine spezielle Funktion, wie beispielsweise der Anlagenausgang, erfüllen. Transitknoten, die nur im Verlaufe der Abarbeitung einer Route durchfahren werden, aber an denen nie eine Route endet, können hierbei ausgelassen werden.\\
		Die Ergebnisse der Dijkstra-Berechnungen werden in einer Tabelle gesichert und als Basis für die Heuristik der Wegfindung mittels A* im zyklischen Betrieb verwendet. Wie in  Abschnitt \ref{Heuristik} gezeigt wurde, ist die Anzahl der expandierten Knoten, und somit auch die Laufzeit, minimal, wenn als Heuristik der exakte Abstand zum Ziel genutzt wird. Dieser Fall ist, unter der Bedingung das sich die Anlage seit dem Hochfahren der CPU nur geringfügig geändert hat, durch die Verwendung der Abstände des entsprechenden Ziels aus der Dijkstra-Tabelle gegeben. Auch bei Änderungen, wie beispielsweise Sperrungen von Kanten oder der Blockade von Teilstrecken durch andere Fahrzeuge, erfüllt diese Heuristik noch die Anforderung $\hat{h}(n)\le h(n)$, da die neue exakte Route sicher länger ist, als die vorausberechnete ideale Route ohne Hindernisse. Bei Hinzufügen neuer Kanten zur bestehenden Anlage muss die CPU neu gestartet werden\footnote{aus im Abschnitt \ref{Knotenliste} beschriebenen Gründen}, da hierdurch kürzere Wege entstehen könnten, welche die Bedingung aus Gleichung \ref{eq:Heuristikbedingung} verletzen würden.
		
		
				





